{
  "version": 3,
  "sources": ["../../svelte-spa-router/wrap.js"],
  "sourcesContent": ["/**\n * @typedef {Object} WrappedComponent Object returned by the `wrap` method\n * @property {SvelteComponent} component - Component to load (this is always asynchronous)\n * @property {RoutePrecondition[]} [conditions] - Route pre-conditions to validate\n * @property {Object} [props] - Optional dictionary of static props\n * @property {Object} [userData] - Optional user data dictionary\n * @property {bool} _sveltesparouter - Internal flag; always set to true\n */\n\n/**\n * @callback AsyncSvelteComponent\n * @returns {Promise<SvelteComponent>} Returns a Promise that resolves with a Svelte component\n */\n\n/**\n * @callback RoutePrecondition\n * @param {RouteDetail} detail - Route detail object\n * @returns {boolean|Promise<boolean>} If the callback returns a false-y value, it's interpreted as the precondition failed, so it aborts loading the component (and won't process other pre-condition callbacks)\n */\n\n/**\n * @typedef {Object} WrapOptions Options object for the call to `wrap`\n * @property {SvelteComponent} [component] - Svelte component to load (this is incompatible with `asyncComponent`)\n * @property {AsyncSvelteComponent} [asyncComponent] - Function that returns a Promise that fulfills with a Svelte component (e.g. `{asyncComponent: () => import('Foo.svelte')}`)\n * @property {SvelteComponent} [loadingComponent] - Svelte component to be displayed while the async route is loading (as a placeholder); when unset or false-y, no component is shown while component\n * @property {object} [loadingParams] - Optional dictionary passed to the `loadingComponent` component as params (for an exported prop called `params`)\n * @property {object} [userData] - Optional object that will be passed to events such as `routeLoading`, `routeLoaded`, `conditionsFailed`\n * @property {object} [props] - Optional key-value dictionary of static props that will be passed to the component. The props are expanded with {...props}, so the key in the dictionary becomes the name of the prop.\n * @property {RoutePrecondition[]|RoutePrecondition} [conditions] - Route pre-conditions to add, which will be executed in order\n */\n\n/**\n * Wraps a component to enable multiple capabilities:\n * 1. Using dynamically-imported component, with (e.g. `{asyncComponent: () => import('Foo.svelte')}`), which also allows bundlers to do code-splitting.\n * 2. Adding route pre-conditions (e.g. `{conditions: [...]}`)\n * 3. Adding static props that are passed to the component\n * 4. Adding custom userData, which is passed to route events (e.g. route loaded events) or to route pre-conditions (e.g. `{userData: {foo: 'bar}}`)\n * \n * @param {WrapOptions} args - Arguments object\n * @returns {WrappedComponent} Wrapped component\n */\nexport function wrap(args) {\n    if (!args) {\n        throw Error('Parameter args is required')\n    }\n\n    // We need to have one and only one of component and asyncComponent\n    // This does a \"XNOR\"\n    if (!args.component == !args.asyncComponent) {\n        throw Error('One and only one of component and asyncComponent is required')\n    }\n\n    // If the component is not async, wrap it into a function returning a Promise\n    if (args.component) {\n        args.asyncComponent = () => Promise.resolve(args.component)\n    }\n\n    // Parameter asyncComponent and each item of conditions must be functions\n    if (typeof args.asyncComponent != 'function') {\n        throw Error('Parameter asyncComponent must be a function')\n    }\n    if (args.conditions) {\n        // Ensure it's an array\n        if (!Array.isArray(args.conditions)) {\n            args.conditions = [args.conditions]\n        }\n        for (let i = 0; i < args.conditions.length; i++) {\n            if (!args.conditions[i] || typeof args.conditions[i] != 'function') {\n                throw Error('Invalid parameter conditions[' + i + ']')\n            }\n        }\n    }\n\n    // Check if we have a placeholder component\n    if (args.loadingComponent) {\n        args.asyncComponent.loading = args.loadingComponent\n        args.asyncComponent.loadingParams = args.loadingParams || undefined\n    }\n\n    // Returns an object that contains all the functions to execute too\n    // The _sveltesparouter flag is to confirm the object was created by this router\n    const obj = {\n        component: args.asyncComponent,\n        userData: args.userData,\n        conditions: (args.conditions && args.conditions.length) ? args.conditions : undefined,\n        props: (args.props && Object.keys(args.props).length) ? args.props : {},\n        _sveltesparouter: true\n    }\n\n    return obj\n}\n\nexport default wrap\n"],
  "mappings": ";AAyCO,SAAS,KAAK,MAAM;AACvB,MAAI,CAAC,MAAM;AACP,UAAM,MAAM,4BAA4B;AAAA,EAC5C;AAIA,MAAI,CAAC,KAAK,aAAa,CAAC,KAAK,gBAAgB;AACzC,UAAM,MAAM,8DAA8D;AAAA,EAC9E;AAGA,MAAI,KAAK,WAAW;AAChB,SAAK,iBAAiB,MAAM,QAAQ,QAAQ,KAAK,SAAS;AAAA,EAC9D;AAGA,MAAI,OAAO,KAAK,kBAAkB,YAAY;AAC1C,UAAM,MAAM,6CAA6C;AAAA,EAC7D;AACA,MAAI,KAAK,YAAY;AAEjB,QAAI,CAAC,MAAM,QAAQ,KAAK,UAAU,GAAG;AACjC,WAAK,aAAa,CAAC,KAAK,UAAU;AAAA,IACtC;AACA,aAAS,IAAI,GAAG,IAAI,KAAK,WAAW,QAAQ,KAAK;AAC7C,UAAI,CAAC,KAAK,WAAW,CAAC,KAAK,OAAO,KAAK,WAAW,CAAC,KAAK,YAAY;AAChE,cAAM,MAAM,kCAAkC,IAAI,GAAG;AAAA,MACzD;AAAA,IACJ;AAAA,EACJ;AAGA,MAAI,KAAK,kBAAkB;AACvB,SAAK,eAAe,UAAU,KAAK;AACnC,SAAK,eAAe,gBAAgB,KAAK,iBAAiB;AAAA,EAC9D;AAIA,QAAM,MAAM;AAAA,IACR,WAAW,KAAK;AAAA,IAChB,UAAU,KAAK;AAAA,IACf,YAAa,KAAK,cAAc,KAAK,WAAW,SAAU,KAAK,aAAa;AAAA,IAC5E,OAAQ,KAAK,SAAS,OAAO,KAAK,KAAK,KAAK,EAAE,SAAU,KAAK,QAAQ,CAAC;AAAA,IACtE,kBAAkB;AAAA,EACtB;AAEA,SAAO;AACX;AAEA,IAAO,eAAQ;",
  "names": []
}
